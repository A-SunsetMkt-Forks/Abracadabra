# 魔曰 细节和使用指南

[<img src="https://img.shields.io/badge/license-AIPL%201.1-yellow"/>](LICENSE.md)

**Abracadabra(魔曰)** 是一个用于加密短文本/链接的工具。

如果想直接阅读使用指南，请跳到 [**使用指南**](#最佳操作实践)

```
明文 -> 压缩 -> AES-256-CTR -> Base64 -> 三重转轮 -> 映射汉字 -> 组句(仅仿真加密时) -> 密文
```

## 压缩和校验

针对短文本，本项目使用针对短文本优化的 [**Unishox2**](https://github.com/siara-cc/Unishox2) 压缩算法，避免了通用压缩算法(如 GZIP 等)文件头过重的问题。一般数据(>1KB)则采用GZIP。

针对链接和常见域名编排了字典，有效提高特定链接(例如网盘链接)的压缩效率。

压缩后会执行效率验证，如果出现无效压缩，则自动回落到原始数据。

---

项目使用轻量化的 [**卢恩算法**](https://zh.wikipedia.org/zh-cn/%E5%8D%A2%E6%81%A9%E7%AE%97%E6%B3%95)(US2950048， ISO/IEC 7812-1) 来对解密结果做简单校验，能够检出 70%的错误。

卢恩算法比起 Hmac 和 AES-GCM，安全性稍弱，但它十分轻量，校验位仅占一个字节。

## 加密和混淆

### AES-256

AES-256 是业内公认的安全加密算法，久经考验。

魔曰使用 AES-256-CTR 作为密文的核心加密方案，使得密文的安全性有基本的保证。

唯一的不足之处在于初始化向量(IV)的长度，标准长度是 16 字节，但是由于本项目的密文长度必须尽可能地短，便把 IV 长度压缩至两个字节，提供 65536 种随机性，配合转轮混淆，在大多数情况下足够安全。

由于IV(nounce)随机性被削减，可能发生CTR流密钥重用问题。

**如果没有混淆操作**，相同密钥加密出的密文有 N(相同密钥加密的有效密文数量)/65535 的可能导致明文的异或值泄露。

密钥参与的古典转轮混淆很大程度上避免了此问题，如果你在意安全性，请尽可能使用不同的密钥来加密。

---

### 转轮混淆

转轮混淆之前的原文，是一个使用AES加密后数据编码而成的Base64字符串，转轮混淆对其的处理为彻底打乱Base64字符串的字母/数字/符号，使其无法被正常解码为上一层AES256加密后的字节数据(包括两字节IV在内)。

#### 密钥和操作数

1. 对密钥进行SHA256
2. 对SHA256后得到的32字节数组中的每个元素执行对十取余，得到一个操作数数组(这个数组中每个元素的大小不超过9，不小于0)

#### 轮转规则

混淆时，每混淆/映射一个字符，就取当前操作数，执行一次转轮轮转，并将当前操作数的索引偏移一位。  

下次加密便会从操作数数组中取下一个操作数执行转轮轮转。如果取到数组末尾，则从头开始，循环往复。

轮转方向和距离由当前操作数(N)决定。  
遵守以下规则：

- 如果操作数为0，将其当作10并继续

如果该操作数是偶数(N%2 == 0)

- 将第一个密钥轮向右轮6位
- 将第二个密钥轮向左轮N*2位
- 将第三个密钥轮向右轮(N/2)+1位

如果该操作数是奇数(N%2 != 0)

- 将第一个密钥轮向左轮3位
- 将第二个密钥轮向右轮N位
- 将第三个密钥轮向左轮(N+7)/2位

其中，第一个和第三个转轮为顺序轮，第二个转轮为乱序(手动打乱)轮。

转轮每次转动方向和距离由操作数组(密钥)决定
可能的密钥空间为10^32。

#### 映射规则

映射采用 字母 -> 索引 -> 字母 -> 索引 的重复操作。

设立一个原映射标准字符串(实际比这个要长得多)
```
abcdefjhigk....
```

三个转轮的长度和原字符串一致。
假设三个转轮状态如下。
(下一个字符加密时会轮转)
```
bcdefjhigka....
edfbjichgak....
fjhigkabcde....
```

现在，假设我们要混淆字符 a 

1. 在原字符串中找到字符 a 的索引，得到 0
2. 在第一个转轮中查找索引 0，得到字符 b
3. 在原字符串中查找字符 b 的索引，得到 1
4. 在第二个转轮中查找索引 1，得到字符 d
5. 在原字符串中查找字符 d 的索引，得到 3
6. 在第三个转轮中查找索引 3，得到字符 i

由此完成了 a --> i 的转轮映射。

其他所有字符以此类推，均可得到一个映射。  
(这个映射可以和原文本相同，修正了Enigma机的弱点)  

每轮转一次转轮，都会得到一个完全不同的映射表，轮转规则见上一小节。

更多内容参见 [**Issue#30**](https://github.com/SheepChef/Abracadabra/issues/30)

## 汉字映射

### 映射表和模板

魔曰的密本不同于任何同类型的工具，它由数百个《通用规范汉字表》中的一级字和二级字构成，也有一些非常常见的 **日本和制汉字(Kanji)**，比如 **桜(Sakura)**；没有任何让人眼花缭乱的诡异汉字。

密本是纯人工挑选编纂的，映射表公开可查，查阅 [**映射表(传统)**](https://github.com/SheepChef/Abracadabra/blob/main/src/javascript/mapping.json) 或者 [**映射表(仿真)**](https://github.com/SheepChef/Abracadabra/blob/main/src/javascript/mapping_next.json) 以了解密本的全貌。

古文句式模板编纂时参考了《古文观止》和《古文辞类纂》，资料来自 [**中国哲学书电子化计划**](http://ctext.org/zhs)。

---

### 传统模式

>困句夏之全玚凪斋或骏琅咨兆咩谜理金说宙银歌舒

传统模式的密表是几百个常见汉字，加密结果为这些汉字组成的无序字符串。

在传统模式下，会在随机位置对密文添加标志位，用来简化加解密操作流程，程序识别到加密标志位便会自动解密，无需用户手动指定解密，提高便利性。你也可以生成没有标志位的密文，此时需要手动指定强制解密。

传统模式类似此前存在过的诸多加密项目，加密效率高，密文较短，随机性很强，适用于一般场景。

---

### 文言文仿真

>光韵开云，雅于莺茶，停而行之之谓速。是故无悦无谜，无瑞无聪，裳之所走、树之所振也。旧铃之纯水，常为悦水之莹风。人曰：“瑞琴之路，常留于其所允行而不读之处。” 璃非笑而去之者，孰可无鹏。非将选也，非可指也，书非当事涧，仍继叶言，奈何，同森而非航水也，能鸢者益。

文言仿真，会将加密后的字符串映射为仿古文本中的若干个载荷字。

用户可以调整仿真器的随机参数，启用特定风格模板的过滤，最终影响生成的密文风格。

以下是文言仿真的基本步骤：

1. 分配载荷，遇到超大载荷则平均分配，递归分段处理。
2. 在句式库中选择对应载荷量的句式。
3. 在句式模板中插入载荷字，插入时数据经过三重转轮混淆。
4. 在句式和句式之间插入标点符号。
5. 得到完整密文。

用户可以影响载荷分配时的随机因子；在选择句式时，可以打开特定风格的过滤器。

#### 载荷分配

载荷分配本质上是简化了的找零问题。  
将一个给定的载荷量(例如37)，分解成若干个1~9的整数之和。

载荷将被预先按比例分为 Begin, Main, End 三部分，对应一段密文的三节，每节都拥有一个不同的句式库。

有两种策略，分别是贪心算法和随机分配，每个分配步骤都会选择二者之一。

贪心算法在每一步尽可能大地分配载荷，从而得到一个较为整齐的分配结果。

用户可以指定更高的随机因子，增加随机分配的概率(最大100%)，从而得到更加零碎的分配结果。

针对载荷分配，还引入了额外步骤以打乱/合并过于零碎的载荷，尽可能防止密文产生连续的重复模式。

#### 句式模板和密表

句式模板有一个固定的语法，以辅助解析。

```
8D/N/anti/MV/V/N/，/still/继/N/V/，/why/，/and/N/而/anti/V/N/ye/P

// 8 -> 载荷数量
// "/" ->语素分隔符
// N->名词 V->动词 A->形容词 AD->副词
// B->一般句式  C->骈文句式 D->逻辑句式 E->既是骈文句式，又有逻辑
// P->句号 Q->问号 R->冒号和引号 | 依需要添加在句式末尾，代替原有逗号。
// by/why/anti... -> 虚词

// 其他(汉字)原样保留
```

密表则按照词性分类，将动词，形容词，副词，和名词分开映射。

#### 选择句式

给定一个分配的载荷量，以及此时载荷所处的密文节(Begin/Main/End)，算法会在对应句式库里过滤出所有匹配该载荷量的句式。

如果用户没有指定任何过滤器，一般情况下，则在所有载荷量匹配的句式中随机选择一个，无论其分类。  
有 25% 概率将在这些句式中再次过滤出逻辑/骈文句式，然后随机选用其中的一个，如果没有可用的句式，则在所有载荷量匹配的句式中随机选择一个。

如果用户指定了过滤器(骈文/逻辑)，则会再次过滤出可用的骈文/逻辑句式，然后随机选用其中的一个。  
如果对应载荷量没有可用的骈文/逻辑句式，则在所有载荷量匹配的句式中随机选择一个。

总体而言，句式选择提供了较强的随机性和灵活度。

#### 插入载荷字和标点

算法将用分隔符"/"将句式分割成数组，然后丢弃句式的开头部分。

再把每个句子分割出的数组，依次压入一个大数组中，得到一个二维数组。

此时将用两层循环依次遍历数组中的每一个元素：  
- 遇到N/V/A/AD等载荷位，则对表映射一个载荷字，追加到密文字符串上。
- 遇到虚词指示，则在对应虚词库中随机选择一个追加到字符串上。
- 按照一定的规则，在句式和句式之间插入标点符号，或者换行符(分段标志)。
- 遇到汉字或者其他字符，则原样追加到密文字符串上。

由此得到一个强随机性，包含标点符号的文言文密文字符串。

如果用户指定不需要标点符号，那么会执行最后一次过滤，过滤出不含标点符号的密文结果。

更多内容参见 [**Issue#60**](https://github.com/SheepChef/Abracadabra/issues/60)

## 前端和跨平台操作性

魔曰加密是一个跨平台的项目，以 JavaScript 实现，提供 WebAssembly 模块，浏览器插件，和APK安装包。

项目的前端代码是开源的，拥有完善的配套功能和美观的视觉体验，支持 PWA，可以在各种地方使用。

前端使用 Vue 构建，你可以随时下载源码，在你喜欢的地方轻易地部署它。

[<img src="https://img.shields.io/badge/前端源码-9a10b5?style=for-the-badge" width="103" />](https://github.com/SheepChef/Abracadabra_demo)

## 最佳操作实践

### 文言仿真加密

下面列出一些情况下的最佳实践。

#### 仿真随机性

用户在菜单中可以通过滑条来选择句式的随机程度。
如果想增强句子逻辑性，那么请调整至"长句优先"，挑选句式的时候会优先使用最长的可用句，但加密随机性可能受影响。

如果想要更随机，语块长短不一的密文，则推荐选择“适中”或更高。

#### 通顺

如果嫌生成的句子过于生硬，不妨多次尝试生成(多点几下加密)，选择一个看起来最好的密文。  
只要密钥和原文相同，生成出的所有密文均可以正常解密。

#### 逻辑最佳密文

如果想要尽可能生成逻辑上最佳的密文，请打开**逻辑**模式。  
然后将随机性滑条拖到最左侧(0)。

如此可以尽量使密文由尽可能多的转折/逻辑复合句式构成。  
能够达到最大程度的，逻辑意义上的以假乱真。

#### 长度最佳密文

如果想要尽可能生成短的密文，请打开**骈文**模式。  
然后将随机性滑条拖到最左侧(0)。

如此可以尽量使密文由尽可能多的四字/五字骈文句式构成。  
在增强密文文言风格的同时，提升密文的载荷比，使密文缩短。

#### 混合模式

如果不作任何特殊设置，仿真算法会参考概率随机组句。  
如此生成的密文随机性更强，适合一般情况下的使用。

#### 密文的合适长度

不建议生成过长的密文。

过长的密文(>150字)，在逻辑上难以形成链条，在句式上可能出现雷同，在字频上可能出现特征。
因此不推荐将大段文章丢进加密器加密。

#### 与上下文搭配

合适的做法是将加密出来的文言文与上下文搭配。  
这么做可以抵抗多种攻击，也让BERT之类的模型难以对文本进行分类。

---

### 传统模式加密

下面列出一些情况下的最佳实践。

#### 安全优先

如果你需要最高的安全性，则在加密时设置一个尽可能长和复杂的密码。

最好勾选“去除标志”，来提升密文随机性。

解密时将需要对方勾选强制解密。

#### 效率优先

你可以不填密码，这将会使程序自动用内部的默认密码`ABRACADABRA`加/解密。

把密文的识别交给标志位，这么做可以让他人很方便地解密。
